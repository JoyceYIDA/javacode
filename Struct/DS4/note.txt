
节点的度：子节点的个数
叶子结点：度为0的结点，也称为终端节点；
节点的高度：节点到叶子结点的最长路径
节点的深度：根节点到节点的的路径
树的高度：根节点的高度
节点的层数：深度+1

树的特性：1、子树是不相交的；
         2、除了根节点以外，每个节点有且只有一个父节点；
         3、一棵N个节点地树有N-1条边

树的存储：
   数组存储：顺序存储，适合存储完全二叉树，否则会有空间浪费 应用场景：堆（就是完全二叉树）

   链表存储：
   二叉链：
   class Node{
      Object data;
      Node left;
      Node right;
   }
   三叉链:平衡二叉树
    class Node{
         Object data;
         Node left;
         Node right;
         Node parent;
    }

二叉树：最多只有两个子树
二叉树具有天然的递归特性；出口——叶子结点
满二叉树：一个二叉树每一层的节点数都达到最大值。
        每一层的节点个数为2^（n-1）;n为层数
        总节点：2^n-1；
        数的高度：节点个数为n，求树的高度h=log以2为底（n+1)
完全二叉树：除了最后一层节点个数可以不满外，所有层的节点数都要达到最大值，并且最后一层节点靠左排列。
树的应用：操作系统的文件夹；公司中的职位分布；图书馆的分类
树的结构优势：方便查找、删除
二叉搜索树：（使用最多的二叉树）
      特点：1.根节点一定大于左子树的所有节点，一定小于右子树的所有节点
           2.不包含重复元素
           3.元素可比较
二叉树遍历：按照相应的规则将二叉树中每个结点访问一次
所谓的序指的是每个子树根节点的访问顺序

前中后序遍历称为树的深度优先遍历
所有数据结构的深度优先遍历的非递归实现都是借助栈来实现，模拟操作系统的栈

前序：先访问一个节点的根节点，再访问左子树，最后访问右子树（当前根节点第一次被访问时输出）
      一般用它来输出二叉树

中序：先访问左子树，再访问根节点，再访问右子树（当前根节点第二次被访问时输出）二叉搜索树排序后的结果
后序：先访问先左子树，然后右子树，最后根（当前节点第三次被访问时输出）；应用场景：内存释放

广度优先遍历（操作系统用队列实现，借助队列）
层序遍历:用于搜索策略；用于无权图最短路径；

删除任意节点：找到该节点的前驱或者后继节点，替换（Hibbard Delection）
前驱节点：以当前root为根节点二叉树中小于二叉树中root的最大值节点
后继节点：

floor:小于该值在二叉树中的最大值节点
ceil：大于该值在二叉树中最小值节点

rank：给每个节点排序的输出值
select：
二分搜索树对输的结构没有要求，对值的要求：
查找的时间复杂度O(height)与树高成正比
O(log2 n);
如果只有左子树或右子树（插入数据近乎有序），此时二分搜索树退化为链表，时间复杂度退化为O（n）

解决只有左子树或者右子树的问题：平衡二分搜索树（AVL，红黑树）【每个节点的左右两个子树高度差不超过1】


堆：完全二叉树 顺序存储
优先级队列：
平衡二叉树：
    AVL
    红黑树
123的非递归

456

2

数据结构中的堆一般是完全二叉树（二叉堆）
优先级队列：PriorityQueue按照优先级大小先入先出
只有完全二叉树可以用数组顺序存储。
堆中（完全二叉树）任何一个节点的值不大于其父节点的值（最大堆或大顶堆）
特点：1、在最大堆中，根节点的值一定是堆的最大值；但是不一定层数越高值越大。
     2、堆使用数组存储时，下标为0的存储第一个元素，若当前节点的下标为x，左孩子的坐标为2x+1;
     右孩子为2x+2;父节点下标（x-1）/2;
添加元素：add(E e):默认在数组末尾添加元素，此时添加元素之后可能会破坏堆的定义
         siftUp上浮
         元素放满了就扩容，末尾添加后上浮；

删除元素：将堆顶元素和当前元素交换
        下沉 siftDown；终止条件：当前节点
        判断一个节点是否为叶子结点（在完全二叉树中）左孩子的节点下标>当前二叉树节点个数；该节点一定是叶子结点。

堆排序：时间复杂度不会退化

优先级队列：java.util.PriorityQueue是一个基于最小堆的优先级队列
获取N个元素是的前k个元素
1.遍历元素集，将具体的key值与其出现频率保存在一个map中
2.使用优先级队列存储出现频率最高的前k个键值对
3.使用list存储优先级队列中的所有key值














