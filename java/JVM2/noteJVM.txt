JVM:Java虚拟机
    虚拟机就是通过软件模拟的具有完整硬件功能、运行在完全隔离环境中的计算机系统。（VMWare/Virtual Box）
    JVM是通过软件模拟Java字节码指令集，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。
    从JDK1.3至今，HotSpot为默认JVM
    JVM不是只能跑Java，还可以跑Scala、Koltin
 Java内存区划分--共6块区域
    线程私有内存：每个人线程都有，彼此之间完全隔离。
        JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，所以在任何一个确定的时刻，
        一个处理器（如果是多核处理器则指的是一个内核）都只会执行一条线程中的指令。所以为了切换线程后能恢复到正确的执行位置，
        每条线程都需要独立的程序计数器，来保证各个线程之间计数器互不影响，独立存储。就把类似这类的区域称为线程私有。

    1.程序计数器：是比较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。
      如果当前线程执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；
      如果正在执行的是一个Native方法，这个计数器值为空。
      程序计数器是唯一一块不会产生OOM异常的区域。
    2.虚拟机栈：描述的是Java方法执行的内存模型
          每个方法执行的同时都会创建一个栈帧用于存储局部变量、操作数栈、动态链接、方法出口等信息。
      每一个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机中入栈和出栈的过程，生命周期与线程相同。
      之前我们一直讲的栈区域其实就是虚拟机栈，是虚拟机栈中的局部变量表部分。
      局部变量表存放了编译器可知的各种基本数据类型（8大基本数据类型）+对象引用。
      局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，
      在执行期间不会改变局部变量表的大小。
      异常：1.线程请求的栈深度大于虚拟机所允许的深度（-Xss设置栈容量），抛出StackOverFlowError异常
      2.虚拟机在动态扩展时无法申请到足够的内存，会抛出OOM（OutOfMemoryError）异常。
    3.本地方法栈（Native方法）：和虚拟机栈的作用完全一样。区别就是本地方法栈是为虚拟机使用Native方法服务，而虚拟机栈是为Java方法服务。
      在HotSpot中，本地方法栈和虚拟机栈是同一块内存。
    线程共享内存：所有线程共享此内存空间，此空间对所有线程可见。
    1.堆（GC堆）：JVM所管理的最大内存区域。Java堆是所有线程共享的一块区域，在JVM启动时创建。此内存区域存放都是对象实例以及数组。
      Java堆是垃圾回收管理的主要区域，所以很多时候被称为"GC"堆。Java堆可以处于物理上不连续的内存空间中。
      Java堆在主流的虚拟机中都是可扩展的（-Xmx设置堆的最大值，-Xms设置堆的最小值）
      当堆中没有足够的内存完成实例分配并且堆也无法再拓展时，会抛出OOM异常。
    2.方法区：存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
      JDK8以前也称为永久代，JDK8之后称为元空间（Meta Space）
      JVM规定：当方法区无法满足内存分配需求时，抛出OOM异常。
    3.运行时常量池：它也是方法区的一部分，存放字面量与符号引用。
      字面量：字符串常量（JDK1.7后移动到堆中）、final常量、基本数据类型的值。
      符号引用：类和结构的完全限定名、字段的名称和描述符、方法的名称和描述符。

      public class Test{
          public static void main(String[] args){
             Test test=new Test();
             int a=10;
          }
      }
      test/a都在栈上存放，10在运行时常量池存放，其他的字段都在方法区存放。对象产生->类->具体引用。
Java内存泄漏：无用对象无法被GC
Java内存溢出：内存中的对象确实还存活，但由于堆内存不够用产生的异常。
  判断是溢出还是泄漏：只需要调大参数，如果不再抛出异常，就是内存溢出，否则就是内存泄漏。
  栈溢出多数发生在单线程情况下，OOM多数发生在多线程的情况下。
Java堆溢出：只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免GC清除这些对象，在对象数量达到最大堆容量后就会产生内存溢出异常。
System.gc();//JVM强制进行垃圾回收。所以不能手工释放对象








