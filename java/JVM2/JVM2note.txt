
标记-清除算法：循环遍历；先找出将可回收的标记；再次循环遍历进行清除。
但是不会进行整理，所以产生大量不连续的碎片；并且进行两次遍历，效率低
G1收集器，全区域手机回收器***

jps【】方括号中可以不填，是用来选择的

***判断对象已死
   1.引用计数法：实现简单，判定效率也较高。Python使用引用它来管理内存。但是无法解决循环引用的问题。
   算法思想：给每个对象附加一个引用计数器，每当有一个地方引用此对象时，计数器+1；
   每当有一个引用失效时，计数器-1；在任意时刻，只要计数器值为0的对象就不能再被使用，也就是对象已死。
   JVM没有采用此算法。
   2.可达性分析算法
   Java采用可达性分析算法来判断对象是否存活（C#、Lisp）
   核心思想：通过一系列“GC Roots”的对象作为起点，从这些节点开始向下搜索对象，搜索走过的路径，称为“引用链”。
   当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到对象不可达），证明对象已死。
   Java中能作为GC Roots的对象包含以下四种：
   1.虚拟机栈中引用的对象 2.类静态变量引用的对象 3.常量引用的对象 4.本地方法栈中引用的对象
   ****JDK1.2之后对引用的概念做了扩充
   分为四类：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）（从强到弱）
   强引用指的是代码中普遍存在的，在JVM中只要强引用还存在，垃圾回收器永远不会回收此对象实例。如：Object obj=new Object();
   软引用用来描述一些有用但不必须对象。对于仅被软引用指向的独享，在系统将要发生内存溢出之前，会将所有软引用对象进行垃圾回收。
   若内存够用，这些对向依然保留。在JDK1.2之后提供SoftReference来实现软引用。
   弱引用强度比软引用更差一点。仅被弱引用关联对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作时；无论当前内存是否够用，
   都会回收掉仅被弱引用关联的对象。JDK1.2之后，使用WeakReference来实现弱引用。
   虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，
   也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前，收到一个系统通知。
   JDK1.2以后，提供PhantomReference来描述虚引用。

对象的自我拯救：finalize方法（只能执行一次）在可达性算法中不可达的对象，也并非"非死不可"。
要宣告一个对象彻底死亡，需要进行两次标记过程：
若对象在进行可达性分析后发现GC Roots不可达，此对象会进行第一次标记并且进行第一次筛选过程。
筛选的条件是此对象是否有必要进行finalize().当对象没有覆盖finalize()方法或finalize()方法已被JVM调用过，
JVM将会将此对象彻底宣布死亡。
筛选成功（对象覆写了finalize方法且未被执行），会将此对象放入F-Queue，如果对象在finalize()成功自救（此对象与GC Roots建立联系)，
则对象会在第二次标记时被移除回手机和，成功存活；若对象在finalize中仍然以GC Roots不可达，宣告死亡。

回收方法区：方法区的回收主要回收两部分：废弃常量+无用的类（垃圾回收概率很低）
判断一个类是无用类，必须满足三个条件：
1.该类的所有实例都已经被回收（Java对重不存在该尅的任何实例）
2.加载该类的类加载器已经被回收
3.该类的Class对象没有在任何其他地方被引用，也无法通过反射访问该类的所有内容。



























