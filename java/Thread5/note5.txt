
同步锁的优化：（优化的是等待的时间）
1.CAS操作（乐观锁），比较和交换，有三个值：内存中的实际值V,期待值O，更新后的值N。
  多个线程竞争同一个锁的时候，线程1判断V==O的话，则线程1成功，其他线程失败；失败则判断线程2，若V==O，则线程2成功，其他线程失败；
  失败就继续判断下一个线程（先判断哪个线程是随机的）CAS操作的结果是只有一个线程会成功并且成功更新，其他线程都失败。
  那么CAS操作就会引发一些问题：
  1）ABA问题，一个旧值从A变成了B，然后再变成了A，刚好在做CAS时检查到旧值没有变化，但实际上变了。
     解决方案：添加版本号，在JDK1.5以后的atomic包里提供了AtomicStampedReference解决ABA问题
  2）失败重试带来的自旋问题，自旋会浪费大量的CPU资源
     解决方案：自适应自旋，根据以往自旋等待时但能否获取到锁来调整自旋的时间，也就是循环数。
  3）公平性：自旋带来的副作用，出于阻塞状态的线程，无法立刻竞争被释放的锁，然而处于自旋状态的线程很有可能先获取待这把锁。
     内建锁无法实现公平机制，但是Lock体系可以实现公平锁。
2.Java对象头
  锁的四种状态，并按级别由低到高：
  无锁状态
  偏向锁状态：一个线程访问一个资源，产生竞争（多线程）
  轻量级锁状态：多个线程在不同时间竞争同一个资源
  重量级锁状态：多个线程在同一时间竞争同一个资源
优化的前提：多个线程同一时间访问同一个资源产生竞争，会有线程阻塞和唤醒。
JVM开发者发现，多个线程访问同一个资源大多数都不是同一个时间
锁的升级：无锁-》偏向锁-》轻量级锁-》重量级锁（无同步，无synchronized）

锁粗化：将多次连接在一起的加锁解锁操作合并成一次，将多个连续的锁扩展为一个范围更大的锁。
锁消除：根据代码逃逸技术，如果判断一段代码中，堆上的数据不会逃逸出当前线程，不会被多个线程访问，就认为这段代码是安全的，不必要加锁
死锁：一个线程等待另一个线程执行完毕后才可以继续执行，但如果现在相关的线程彼此都在等待着，那么就会造成死锁。
死锁会浪费CPU资源。

ThreadLocal(值没有共享，线程变量独立)
  同步机制是为了保证多线程环境下数据的一致性，而ThreadLocal是为了保证多线程环境下数据的独立性。
  对于ThreadLocal类型的变量，在一个线程中设置值，不影响他在其他线程中的值，也就是ThreadLocal类型的变量的值在每个线程中是独立的
  ThreadLocal的实现：（看源码）
  1）set(T value)
  Thread t = Thread.currentThread();说明每次都是当前线程
  获取到当前线程的ThreadLocalMap，如果ThreadLocalMap不为null，则将value保存到ThreadLocalMap中，并用当前ThreadLocal作为key；
  否则创建一个ThreadLocalMap并给到当前线程，然后保存value。

  ThreadLocalMap相当于一个HashMap，是真正保存值的地方。
  2）get()
   获取到当前线程的ThreadLocalMap，如果ThreadLocalMap不为null，则把获取的key为当前的ThreadLocal的值;
   否则调用setInitialValue()方法返回初始值，并保存到新创建的ThreadLocalMap中。

  ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue)key-value键值对，构造方法会创建一个数组，
  并把第一次需要保存的键值存储到一个数组中，完成一些初始化工作
  3）Entry存储对象
  Entry用于保存一个键值对，其中key以弱引用（垃圾回收时，如果内存不够，不管是否引用都会被回收）的方式保存。
  Java中的引用：A：强引用，由一个类直接创建对象如String str="hello";
  B：弱引用  C：软引用  D：幻引用（幽灵引用）
  4）内存泄漏
  Entry中的弱引用会降低内存泄漏发生的概率，但是不能完全避免内存泄漏。
  在调用ThreadLocal的get、set和remove的时候都会清除当前线程ThreadLocalMap中所有所有key为null的value。
  这样可以降低内存泄漏发生的概率。
  因此在使用ThreadLocal的时候，每次用完ThreadLocal都调用remove方法，清除数据，防止内存泄漏。



