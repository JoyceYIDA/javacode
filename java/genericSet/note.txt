类集实际上就属于动态对象数组。（当元素个数达到最大值时，动态增加容量）解决数组定长问题。
    Java类集实际上去就是java对数据结构的一种实现；---java.util
    1. Collection接口（单个对象保存的最顶层父接口）
       Collection接口以及其子接口在每次进行数据结构操作时只能对单个对象进行处理；
       只定义了存储数据的标准，但是无法区分存储类型。
       所以常用的是他的两个子类：List和Set
       public interface Collection<E> extends Iterable<E>
       public Iterator<E> iterator();取得集合的迭代器，在JDK1.5之前是写在Collection接口中
               interface Iterable
            1.1 Collection接口中的核心方法：
                  add(T t)：向类集中添加元素
                  iterator()：取得类集的迭代器
       1.2.List接口（允许数据重复）
          在进行单个集合处理时，优先考虑List接口
          List接口中拓展了两个重要方法：get(int index)：根据所以下标取得元素；set(int index,E element)：根据索引下标更新数据
       ***三个子类使用上没有任何区别；区别：
          {
          1.出现版本：
          ArrayList JDK1.2
          Vector    JDK1.0
          2.调用无参构造初始化策略：
          ArrayList 在构造方法阶段并不初始化对象数组，在第一次添加元素时才初始化对象数组
          Vector    在无参构造执行后将对象数组大小初始化为10
          3.扩容策略
          ArrayList 扩容变为原来的1.5倍
          Vector    扩容为原来的2倍
          4.线程安全性
          ArrayList 异步处理，性能较高，线程不安全
          Vector    同步处理，性能较低（原因，才用在方法上加锁，除了内键锁还可以使用lock），线程安全
          （即使要使用线程安全的List，也不用vector）
          5.遍历
          Vector支持较老的迭代器Enumeration，
          ArrayList不支持
          }
          {
          ArrayList  底层采用数组实现
          LinkedList 底层采用双向链表
          都采用异步实现
          }

          1.2.1 ArrayList
                默认数组长度为10
                private static final int DEFAULT_CAPACITY = 10;
                   扩容1.5倍
                2.1.1.无参构造
                2.1.2.有参构造 int定义初始化容量，用户自定义
                2.1.3.有参构造 从某个位置插入某个值
                      接口能保证参数的统一
                List接口想要保存自定义类的对象（contains、remove等方法）：需要覆写equals和hushCode方法
                可以使用concurrent包提供的工具将ArrayList变为线程安全的集合
          重复元素的比较：系统Object和Integer自动覆写了equals和hashCode方法，所以不用重新覆写
                equals不一定比较的都是内容，在Object类里equals是用==实现，覆写后比较的才是内容
                equals和hushCode成对存在，所以要一块覆写

           1.2.2 Vector
                 默认数组长度10
           1.2.3 LinkedList
      1.3.Set集合（不允许数据重复）
          1.3.1 HashSet（无序存储）底层使用哈希表+红黑树，允许存放空值
          1.3.2 TreeSet（有序存储）底层使用红黑树，不允许出现空值（NullPointerException）
                要想将自定义类保存到TreeSet中，要么实现Comparable接口，要么向TreeSet中传入比较器（Comparator外部排序接口）
                java.lang.Comparable接口（内部比较器）-排序接口,只有一个参数，拿自己和别的比
                   一个类如果实现了Comparable接口则说明该类支持排序
                   排序方法：Collection.sort或Arrays.sort
                Comparator外部排序接口（外部比较器）：若要控制某个自定义的顺序，而该类本身不支持排序（类本身没有实现Comparable接口）
                    我们可以建立一个该类的“比较器”来进行类的排序。
                    int compare(T o1,T o2);返回值与compareTo返回值完全一样，
                    返回正数,表示o1>o2;返回0,表示o1=o2;返回小数，表示o1<o2;
                    实现了Comparator接口进行第三方排序--策略模式，此方法更加灵活，可以轻松改变策略进行第三方的排序算法
    重复元素的比较：TreeSet和TreeMap依靠Comparator或Comparable接口来区分重复元素。
                  自定义想要保存在TreeSet或TreeMap中；
                  1.直接实现Comparable接口，覆写CompareTo方法
                  2.实现一个比较器传入TreeSet或TreeMap来进行外部比较
             而HashSet与HashMap并不依赖比较接口，此时想要区分自定义的元素是否重复，同时覆写equals和HashCode方法。
             覆写equals方法的五个原则：
             自反性：对于任何非空引用值x，x.equals(x)都返回true；
             对称性：对于任何非空的x，y,当且仅当x.equals(y)返回true,y.equals(x)也返回true
             传递性：对于任何非空的x,y,z,如果x.equals(y)返回true，y.equals(z)返回true，一定有x.equals(z)返回true;
             一致性：对于任何非空的x,y
             非空性：
             先调用hashCode（保证属性值相同的元素在一个桶中）计算出对象Hash码决定存放的数据桶，而后使用equals来比较元素是否相等，若相等，则不再放置元素，
             若equals（保证同一个桶中属性值相同不再设置）返回false，则在相同桶之后，使用链表将若干元素链起来
             若两个对象equals方法返回true，他们的hashCode必然要保证相等
             但是两个对象的hashCode相等，equals不一定相等
             当且仅当equals与hashCode方法均返回true，才认为两个对象真正相等。
       1.4 集合输出（迭代器输出）
       1.4.1迭代器：未来遍历集合而生----迭代器模式，只能从前向后输出（只有Collection集合可以使用）
       调用Collection集合子类的Iterator方法取得内置的迭代器
           Iterator(Scanner implements Iterator)
           两个核心方法：boolean hasNext();判断是否还有下一个元素 E next();取得下一个元素
       1.4.2双向迭代接口：ListIterator；List接口提供，Set不支持
       除了hasNext和next方法外，还有：hasPrevious():判断是否有上一个元素；previous：取得上一个元素
       要想使用从后向前遍历输出，首先至少要从前向后遍历一次才可使用。
       1.4.3Enumeration（JDK1.0）枚举输出-Vector类支持
       hasMoreElements():判断是否有下一个元素；nextElements():输出下一个元素
       1.4.4for-each各个集合都可以使用
       能用foreach输出的本质在于各个集合类都内置了迭代器
       fail-fast
       CurrentModificationException发生在Collection集合使用迭代器遍历时，使用了集合类提供的修改集合内容方法报错
       而如果使用Iterator迭代器的remove()不会出现此错误
       但是在迭代器遍历时，不要修改集合内容！！！
       不能直接list.remove();要在迭代器里list.remove()
       快速失败策略保证了所有用户在进行迭代遍历集合时，拿到的数据一定是最新的数据（避免“脏读”产生）
       fail-safe
       不产生ConcurrentModificationException异常









