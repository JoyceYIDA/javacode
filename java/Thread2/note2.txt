守护线程（后台线程）：是一种特殊的线程，属于陪伴线程（垃圾回收线程）
Java中两种线程：用户线程（false）和守护线程（true），可以用isDaemon()来判断是不是守护线程
只要当前JVM进程中存在任何一个用户线程没有结束，守护线程就在一直工作，只有当最后一个用户线程停止后，守护线程会随着JVM进程一同停止。
setDaemon()将当前线程设置为守护线程
Java中启动的线程默认为用户线程，包括main线程。
***线程的同步：
同步问题：每一个线程对象轮番抢占共享资源带来的问题（单线程不存在同步问题）
1.同步处理：
     1）：使用synchronized关键字来处理同步问题
     synchronized处理同步有两种模式：同步代码块、同步方法
     要使用同步代码块必须要设置一个锁定的对象，一般可以锁当前对象this
     同步方法:在方法上添加synchronized关键字，表示此方法只有一个线程能进入。
     隐式锁对象，this
     如果一个类中有两个同步方法，线程1进入了第一个同步方法，第一个同步方法内部是死循环，线程1还没有释放锁，那么线程2能否进入第二个同步方法？？？
     ！！！不能，一定不能，一定要看对象；锁的是对象，此时线程1可以调用第二个同步方法，因为此时线程1拿到了锁
     2）：synchronized底层实现
     同步代码块：
     锁类的实例对象synchronized(this){}
     锁类对象(class对象)synchronized(类名称.class){}-全局锁
     锁任意实例对象,如：String lock="";synchronized(lock){}
     同步方法：
     1.普通方法+synchronized：锁的是当前对象
     2.静态方法+synchronized：锁的是类-全局锁，效果等同于同步代码块的锁类对象
     *****对象锁（monitor）机制--JDK6之前的synchronized（重量级锁）效率非常低
     同步代码块：执行同步代码块后首先要执行monitorenter指令，退出时执行monitorexit指令。
     使用内键锁（synchronized）进行同步，关键在于获取指定锁对象monitor对象，当线程获取monitor后才能继续向下执行，否则就只能等待。
     这个获取过程是互斥的，即同一时刻只有一个线程能获取到对象monitor
     通常一个monitorenter指令会包含多个monitorexit指令。原因在于JVM需要确保锁在正常执行路径以及异常执行路径上都能够正确的解锁。
     同步方法：当使用synchronized标记方法时，编译后字节码中方法的访问标记多了一个ACC_SYNCHRONIZED。
     该标记表示，进入该方法时，JVM需要进行monitorenter操作，退出该方法时 ，无论是否正常返回，JVM均需要进行monitorexit操作。

     当执行monitorenter时，如果目标锁对象的monitor计数器为0，表示此对象没有被任何其他对象所持有。
     此时JVM会将该锁对象的持有线程设置为当前线程，并且计数器+1；
     如果目标锁对象的计数器不为0，判断锁对象的持有线程是否是当前线程，如果是再次将计数器+1（锁的可重入性）
     如果锁对象的持有线程不是当前线程，当前线程需要等待，直至持有线程释放锁。

     当执行monitorexit时，JVM会将锁对象的计数器-1，将计数器的值减为0时，代表该锁对象已经被释放。






