1.JDK1.5新特性：
1.1 方法的可变参数
        设计一个方法，可以接收任意个数的整数，并返回他们的结果
        可变参数的本质还是数组
        一个方法只允许一个可变参数，并且可变参数一定是方法最后一个参数
        语法：数据类型...可变参数名称
              int...data
1.2 foreach循环
        只用于数组、类集内容的取得，不能修改原数组、类集内容。
        for（数据类型 临时变量：数组名/类集名）
        for（int temp：data）{
        }
1.3 静态导入
        import static （在使用类中导入了整个类中的静态域【静态属性、静态方法】，不用加类名直接用）
        推荐用类名调用静态域
        ctrl+alt+o 自动导入包和自动删除包
2.泛型---守门员（在使用的时候规定了类型，安全性考虑，不再有类型转换异常）
2.1 泛型类
      泛型指的是在类定义的时候并不会设置类中属性或方法的参数的具体类型，而是在类使用时再定义
      语法：
      class MyClass<T>{
           T t;
      }
      <>中的T被称为类型参数，用于指代任意类型；T只是一个指代，<>代表泛型。
      出于规范起见，类型参数一般由单个的大写字母表示；D用在泛型类声明上；E一般用于属性；K/V键值对

      当泛型类中需要多个不同类型变量时，<>以，分隔 声明不同大写字母即可
      JDK1.7以后可以Point<String,Integer> point=new Point<>();后面的村塾类型可以不写，但是前面必须定义

      泛型的出现彻底解决了向下转型带来的ClassCastException问题。
      泛型只能使用引用类型，不能使用基本类型，因为基本类型使用包装类自动拆装箱。
2.2 泛型方法
      语法：
      public <T> T method(T t){
        (有<>才是泛型)
          第一个T表示任意类型、表明该方法是一个泛型方法；第二个T表示返回值；第三个T表示参数
      }
      当泛型方法与泛型类共存时，泛型方法中的类型参数与泛型类中的类型参数无关，反省方法始终以自己的类型参数为准。
      规范起见，当泛型类与反省方法共存时，使用不同的类型参数来区分彼此。
2.3 通配符---解决泛型参数统一化问题
   2.3.1  ? 通配符 作用于方法参数声明
        public static void print（MyClass<?> mc)此时方法参数表示可以接收任意类型的MyClass对象
        由于无法确定入参的类型，所以？通配符下的泛型参数，只能取得类中属性值，无法进行属性值的设置。
   2.3.2 设置泛型上限---用于泛型类的声明，也可用于方法参数
        泛型类声明：T extends 类（T<=类）
        方法参数：? extends 类
        比如：? extends Number 表示方法入参只能接收Number以及其子类对象
        public static void print(MyClass<? extends Number> mc)
        方法参数设置泛型上限还是不能设置值，父类不一定能向下转型变为子类
   2.3.3 设置泛型下限---只能用于方法参数，不能用于泛型类
        ? super 类（>=类）
        表示方法入参只能接收类以及父类对象
        此时可以设置值，因为子类可以发生天然的向上转型变为父类。
2.4 泛型接口
         1.子类实现接口时继续保留泛型
           class Apple<T> implements IFruit<T>{}
         2.子类实现接口时就确定好类型
           class Orange implements IFruit<String>{}
2.5 泛型抽象类
2.6 类型擦除




