JDK1.5新增java.util.concurrent.locks提供了与内建锁完全不同的实现多线程共享资源访问机制。
失去了内建锁隐式的加锁与解锁过程，增加了可中断的获取锁以及超时获取锁以及共享锁等内建锁不具备的特性。
Lock比内建锁多了可中断锁、超时锁和共享锁。
lock锁的标准使用形式
lock是一个接口，lock可以响应中断
Lock lock=new ReentrantLock();
try{
   lock.lock;
   //同步块
}finally{
   lock.unlock();
}(在try代码块里获取锁，finally块里解锁）
Condition(是一个接口，Lock锁的等待队列，内建锁的等待队列只有一个，而lock的等待队列可以是多个)
1. lock接口API

   1）void lock();//获取锁
   2）void lockInterruptibly() throw InterruptedException;//获取锁的过程能够响应中断(lock独有)
   3）boolean tryLock();//非阻塞式响应中断，获取锁返回true，繁反之返回false。可以响应中断。
   4）boolean tryLock(long time,TimeUnit unit):在3的基础上增加了超时等待机制，规定时间内未获取到锁，线程直接返回（lock独有）
   5）void unlock();//解锁

2.AbstractQueuedSynchronizer（AQS同步器），lock体系最核心的存在(int型变量和同步队列)
同步器使用来构建锁与其他同步组件的基础框架。他的实现主要是:依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成同步队列。
要使用AQS，推荐使用静态内部类继承AQS，覆写AQS中的protected用来改变同步状态的方法，其他方法主要是实现排队与阻塞机制。
状态更新使用getState()获取当前线程状态、setState()、compareAndSetState()

Lock面向使用者，定义了使用者与锁交互的接口，隐藏了实现细节：
    AQS面向锁的实现者，简化了锁的实现方式，屏蔽了同步状态的管理，线程排队和线程等待与唤醒等底层操作。


















