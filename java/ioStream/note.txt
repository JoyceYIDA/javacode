字节流与字符流
1.输入流与输出流
      1.1 字节操作流（原生操作，无需转换）
           1.1.1字节输出流（OutputStream）
              public abstract class OutputStream implements Closeable,Flushable;
              是一个抽象类，要想为父类实例化对象就必须要使用子类
                  接收File类（覆盖）：public FileOutputStream(File file)
                  接收File类（追加）：public FileOutputStream(File file,boolean append)
                  在进行文件输出的时候，文件可以不存在但是文件夹必须存在
           1.1.2字节输入流（InputStream）
              public abstract class InputStream implements Closeable;Closeable判断文件是否读到了末尾
              是一个抽象类，要想为父类实例化对象就必须要使用子类
              public FileInputStream(File file)
              public int read(byte b[])读取数据

      1.2 字符操作流（增加了第三方，是经过处理后的操作）
           1.2.1字符输出流（Writer）抽象类
                适合中文数据的处理
                public void write(String str)
                操作文件使用FileWriter子类
                比OutputStream多提供直接写入字符串的功能
           1.2.2字符输入流（Reader）抽象类
                对文件的读取使用FileReader子类
                在Reader类中没有方法可以直接读取字符串类型，只能通过字符数组来进行
      1.3 字节流VS字符流
          字符流适合处理中文文本，一般优先考虑字节流，因为在字符流中所有的字符都需要通过内存缓冲区来进行
          close();是关闭流操作；若字节流未关闭，系统会默认关闭；但是如果字符流未关闭，数据在缓存区中存放，不会输出到终端，这个时候就必须要强制刷新。
          对象.flush();表示强制清空缓冲内容，所有内容都输出。
转换流
    OutputStreamWriter（父类是Writer）:将字节输出流变为字符输出流（Writer对于文字的输出要比OutputStream方便）
    InputStreamReader （父类是Reader）：将字节输入流变为字符输入流（InputStream读取是字节，不方便中文的处理）
    byte--->char 编码
    char--->byte 解码
内存流：
    1.字节内存流：ByteArrayInputStream/ByteArrayOutputStream
    2.字符内存流：CharArrayReader/CharArrayWriter
    内存流可以实现两个文件的合并处理（文件量不大）
        合并两个文件：
        思路一：data-a.txt =>data.txt
               data-b.txt append =>data.txt
               适合大量的合并
        思路二：data-a.txt =>ByteArrayOutputStream
               data-b.txt =>ByteArrayOutputStream
               ByteArrayStream => FileOutputStream
               因为在内存中进行，内存有限，所以该方法适合小量文件的合并
        如果只是使用InputStream类，在进行数据读取的时候会很不方便，结合内存流会好很多
打印流：
    打印流解决的是OutputStream的设计缺陷（OutPutStream只能写成字节或者字节数组）
    如果操作的不是二进制数据想输出的话1.所有数据必须转换为字节数组2.如果要输出的是int、double等类型就很不方便
    1.字节打印流：public PrintStream(OutputStream out)
    2.字符打印流：public PrintWriter(OutputStream out)  public PrintWriter(Writer out)
    打印流属于装饰设计模式：核心依然是某个类的功能。
    3.格式化输出：
    JDK1.5开始 PrintStream类中也可以使用一些占位符（%s,%c,%d等）
    在String类中追加有一个格式化字符串方法：public static String format(String format,Object...args)
    Ajax（异步JavaScript和XML；是一种创建交互式网页应用的网页开发技术）都是打印流支撑的
System类对IO的支持
    1.在System类中定义了三个操作的常量：
        1.1 标准输出（显示器）：public final static PrintStream out
        1.2 错误输出：public final static PrintStream err
        1.3 标准输入（键盘）：public static InputStrwam in
        我们一直在使用的System.out.println()属于IO的操作范畴
    2.系统输出
        系统输出的两个常量：
        1.out输出的是希望用户能看到的内容
        2.err输出的是不希望用户看到的内容，只是作为一个保留的属性而存在
        这两个常量都是PrintStream的实例化对象，而PrintStream又是OutputStream的子类，
        所以可以直接使用System.out直接为OutputStream实例化
    3.系统输入
        System.in可以通过InputStream来实例化对象
        但是要创建一个字节数组，开辟的字节数组长度固定，如果输入的长度超过了字节数组长度，就只能接收部分数据。
        那么就可以引入内存操作，将数据先保存在内存流中然后再取出。
两种输入流
    1.字节缓冲流（BufferedInputStream）
    2.字符缓冲流（BufferedReader）
        BufferedReader类属于一个缓冲的输入流，是一个字符流的操作对象
        String readLine()这个方法可以读取一行数据（以回车为换行符）
        构造方法:public class BufferedReader extends Reader
        public BufferedReader(Reader in)

