
Java中多线程的实现
1. 继承Thread类，覆写其中run()方法
   多线程的启动：start方法。
2. 实现Runnable接口（优先使用）函数式编程接口
   Thread类的核心功能是进行线程的启动，如果一个类为了实现多线程直接去继承Thread类就会有继承局限
   在多线程的处理上使用的就是代理设计模式。
   使用Runnable接口实现的多线程的程序类可以更好地描述出程序共享或资源共享的概念

3. 实现callable接口（泛型接口）java.util.concurrent
   唯一一个线程执行完有返回值的实现
4. 线程池

主方法本身就是一个线程，JVM是一个进程，所有的线程都是通过主线程创建并启动的。主线程的线程名就是main
1.线程休眠：sleep()静态、本地方法
 运行状态-》阻塞状态，sleep执行完 阻塞状态-》就绪状态
让线程暂缓执行一下，等到了预计时间之后再恢复执行。线程休眠会交出CPU，让CPU去执行其他任务。
sleep不会释放锁，也就是说，如果当前线程持有某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。
休眠时间以毫秒作为单位。
线程休眠是随机恢复的，不是同时休眠，所有代码真正进入到方法的对象可能是多个也可能是一个，进入代码的顺序可能有差异，但是总体的执行是并发执行。

2.线程让步：yield()静态、本地方法 static native
暂停当前正在执行的对象，并执行其他线程 运行状态-》就绪状态
调用yield不会让线程进入阻塞状态，他只需要等待重新获取CPU执行时间，不能控制具体交出CPU的时间

3.线程中断：join() 成员方法 final
运行状态-》阻塞状态，会释放锁，执行完 阻塞状态-》就绪状态
join()方法只是对Object类中的wait()方法做了一层包装而已

线程停止：
1.设置标记位，可以使线程正常退出、
2.使用stop方法强制使线程退出，但是该方法不太安全，已经被废弃了
3.使用Thread类中的一个interrupt()可以中断线程。

interrupt():只是改变中状态而已，他不会中断一个正在运行的线程。
实际也就是给受阻塞的线程发出一个中断信号，这样受阻线程就得以退出阻塞的状态。

1.线程中没有调用wait() sleep() join()
isInterrupt():true

2.当调用interrupt()抛出中断异常，catch块中捕获异常，退出。
中断状态重置为false

线程的优先级：线程的优先级越高越有可能先执行，仅仅是有可能而已。
Java默认优先级为5，取得优先级方法 public final int getPriority()
主方法只是一个中等优先级
线程具有继承性

